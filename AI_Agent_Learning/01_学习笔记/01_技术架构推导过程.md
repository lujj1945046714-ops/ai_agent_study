# AI 求职助手 - 技术架构设计

## 更新时间
2026-02-23

---

## 一、系统定义

### 输入
```
用户背景 (user_profile.json)
  - 技能：Python, ML基础, LLM API, RAG经验
  - 约束：一周时间，应届生

搜索偏好 (运行时输入)
  - 城市：上海/北京/...
  - 薪资范围：20-30k/...
  - 岗位关键词：AI Agent, LLM, ...
```

### 输出
```
1. 匹配职位排名列表（含评分和理由）
2. 每个职位的技能缺口分析
3. 推荐 GitHub 项目 Top 3（含推荐理由和难度）
4. 每个项目的具体改进建议（技术深度方向）
```

---

## 二、数据流设计

```
用户背景 (user_profile.json)
         +
搜索条件 (city, salary, keywords)
         ↓
┌─────────────────────────┐
│   数据采集模块            │  nanoclaw 操作 Boss直聘
│   scraper.py             │  输出：原始职位列表
└─────────────────────────┘
         ↓
┌─────────────────────────┐
│   去重检查               │  查询 SQLite: job_id 是否已存在
│   database.py            │  新职位才进入下一步
└─────────────────────────┘
         ↓
┌─────────────────────────┐
│   职位分析模块            │  LLM 读取完整 JD
│   analyzer.py            │  输出：结构化要求 JSON
└─────────────────────────┘
         ↓
┌─────────────────────────┐
│   匹配筛选模块            │  LLM 对比用户背景
│   matcher.py             │  输出：匹配分 + 技能缺口
└─────────────────────────┘
         ↓
      Top 5 职位
         ↓
┌─────────────────────────┐
│   GitHub 推荐模块         │  LLM扩展关键词 → GitHub API
│   github_recommender.py  │  → LLM评估README → Top 3
└─────────────────────────┘
         ↓
┌─────────────────────────┐
│   改进建议模块            │  输入: JD要求 + 项目README
│   suggestion.py          │  输出: 3条具体技术改进方向
└─────────────────────────┘
         ↓
      输出报告 (Markdown)
```

---

## 三、模块精确定义

| 模块 | 输入 | 输出 | 技术 |
|------|------|------|------|
| 数据采集 | 搜索条件 | 原始职位列表 {title, company, salary, jd_text, job_id} | nanoclaw |
| 职位分析 | jd_text | {required_skills[], nice_to_have[], core_work[], tech_stack[]} | LLM API |
| 匹配筛选 | 用户背景 + 结构化要求 | {score: 0-100, skill_gaps[], match_reasons[]} | LLM API |
| GitHub推荐 | skill_gaps[] | [{name, url, stars, reason, difficulty, time_estimate}] | GitHub API + LLM |
| 改进建议 | jd_text + project_readme | [{direction, technical_depth, why_relevant}] | LLM API |
| 数据存储 | 职位数据 | 持久化 + 去重 | SQLite |

---

## 四、关键技术难点与解法

### 难点1：个性化项目适配度建模

**问题：** 如何判断 GitHub 项目"适合你"？

**解法：** 多维度加权评分
```python
fit_score = (
    skill_match_score * 0.4 +   # 技术栈匹配（有RAG经验 → RAG项目加分）
    time_feasibility   * 0.3 +   # 可行性（代码量、文档质量）
    resume_value       * 0.3     # 简历价值（与目标岗位相关性）
)
```

**评分细节：**
- `skill_match`：项目用到的技术 ∩ 用户已有技能 / 项目总技术点
- `time_feasibility`：用 LLM 读 README，估算"一周内能理解并改进"的可能性
- `resume_value`：项目技术 ∩ JD要求的关键词覆盖率

---

### 难点2：Token 优化 - 渐进式筛选

**问题：** 50个职位全部深度分析，费用太高

**解法：**
```
第1轮：50个职位
  → LLM 只看 title + salary（极少token）
  → 按薪资/城市硬筛 → 保留 20 个

第2轮：20个职位
  → LLM 读完整 JD，粗略打分
  → 保留 Top 5

第3轮：5个职位
  → LLM 深度分析 + 技能缺口 + GitHub推荐
  → 生成完整报告（这里可以多花token）
```

**效果：** 相比全部深度分析，token消耗降低约 60-70%

---

### 难点3：nanoclaw 的鲁棒性设计

**问题：** Boss直聘页面结构可能变化，如何保持稳定？

**解法：语义定位而非 CSS 选择器**
```
❌ 脆弱方式：find_element("#job-list > div:nth-child(3) > span.salary")
✅ 鲁棒方式：让 Computer Use 理解"找到职位列表中每条记录的薪资信息"
```

**错误恢复策略：**
- 操作失败 → 截图 → LLM 重新分析当前页面状态 → 重试
- 最多重试 3 次 → 记录失败日志 → 跳过当前职位

---

### 难点4：LLM 输出结构化数据

**问题：** LLM 输出不稳定，难以解析

**解法：**
```python
# 使用 JSON mode 或 function calling
prompt = """
分析以下职位JD，输出JSON格式：
{
  "required_skills": ["Python", "LangChain", ...],
  "nice_to_have": ["RAG", ...],
  "core_work": ["开发Agent流程", ...],
  "tech_stack": ["Python", "FastAPI", ...]
}

JD内容：{jd_text}
"""
# 配合 response_format={"type": "json_object"}
```

---

## 五、项目文件结构

```
02_项目开发/
├── user_profile.json          # 用户背景配置
├── config.py                  # API keys, 搜索参数, 模型选择
├── database.py                # SQLite 操作（增删查改 + 去重）
├── modules/
│   ├── scraper.py             # nanoclaw 数据采集
│   ├── analyzer.py            # LLM 职位结构化分析
│   ├── matcher.py             # 用户背景匹配评分
│   ├── github_recommender.py  # GitHub API + LLM 推荐
│   └── suggestion.py          # 改进建议生成
├── main.py                    # 主流程编排（串联所有模块）
├── prompts/
│   ├── analyze_jd.txt         # 职位分析提示词
│   ├── match_profile.txt      # 匹配评分提示词
│   ├── evaluate_project.txt   # 项目评估提示词
│   └── suggest_improvements.txt # 改进建议提示词
└── output/                    # 生成的报告（Markdown）
```

---

## 六、技术指标与验证方法

| 指标 | 定义 | 目标值 | 验证方法 |
|------|------|--------|---------|
| 召回率 | 找到的合适职位 / 真实存在的合适职位 | >80% | 手动搜索20个职位作对照 |
| 准确率 | 推荐职位中真正合适的比例 | >70% | 人工评估Top5结果 |
| 成功率 | Agent多步骤任务完整执行成功 | >90% | 运行10次统计 |
| Token优化 | 与naive方案相比节省比例 | >50% | 对比渐进式 vs 全量分析 |
| 鲁棒性 | 不同页面结构下成功率 | >85% | 多天运行（页面可能变化）|

---

## 七、MVP 边界（一周可完成）

**做：**
- Boss直聘单一来源
- LLM 分析职位 + 匹配评分
- GitHub API 项目推荐
- SQLite 去重存储
- 命令行界面 + Markdown 报告输出

**不做（过度设计）：**
- 小红书抓取（需要另外研究）
- RAG 知识库（MVP 阶段不需要）
- Web UI
- 多招聘网站

---

## 八、开发顺序建议

```
第1步：user_profile.json + config.py        # 定义数据结构
第2步：database.py                           # SQLite 基础操作
第3步：analyzer.py                           # LLM分析JD（不需要nanoclaw，可以先用mock数据测试）
第4步：matcher.py                            # 匹配评分
第5步：github_recommender.py                 # GitHub API + LLM评估
第6步：suggestion.py                         # 改进建议
第7步：scraper.py                            # nanoclaw（最后做，可以先用手动数据）
第8步：main.py                               # 串联所有模块
```

**关键洞察：** scraper.py 放最后，前6步可以用 mock 数据（手动复制几个JD）来验证整个流程，nanoclaw 只是数据来源，不影响其他模块的开发和测试。
